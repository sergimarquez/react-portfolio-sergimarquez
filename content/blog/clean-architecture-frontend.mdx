---
title: Clean Architecture on Frontend
date: 2025-11-14
summary: Applying clean architecture principles to frontend applications without over-engineering.
tags: [architecture, clean code]
---

Clean architecture isn't just for backend systems. The same principles—dependency inversion, separation of concerns, testability—apply to frontend code. The trick is adapting them without creating unnecessary complexity.

## The Core Idea

**Dependencies point inward**: Your UI components depend on business logic, not the other way around. Business logic doesn't know about React, Next.js, or any framework.

In practice, this means:

```typescript
// ❌ Component knows about API details
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then((r) => r.json())
      .then(setUser);
  }, [userId]);
  // ...
}

// ✅ Component depends on a service
function UserProfile({ userId }) {
  const user = useUser(userId); // Hook wraps the service
  // ...
}
```

The `useUser` hook depends on a `userService`, which handles API calls. The component doesn't care how data is fetched.

## Layers That Matter

**UI Layer**: Components, hooks, pages. Framework-specific, but thin.

**Application Layer**: Use cases, services. Framework-agnostic business logic.

**Domain Layer**: Core entities and rules. Pure TypeScript, no dependencies.

**Infrastructure Layer**: API clients, storage, external services. This is where framework-specific code lives.

## When to Apply It

Not every feature needs this structure. Start simple. Extract layers when you need to:

- Test business logic without rendering components
- Swap implementations (e.g., different API clients)
- Reuse logic across different UI frameworks

## The Balance

Clean architecture helps, but don't create abstractions you don't need yet. Start with clear separation between UI and business logic. Add layers as complexity grows.
